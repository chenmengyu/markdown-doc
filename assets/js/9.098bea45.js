(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{211:function(t,a,s){"use strict";s.r(a);var r=s(0),e=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"区块元素"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#区块元素"}},[t._v("#")]),t._v(" 区块元素")]),t._v(" "),s("h2",{attrs:{id:"段落和换行"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#段落和换行"}},[t._v("#")]),t._v(" 段落和换行")]),t._v(" "),s("p",[t._v("一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。")]),t._v(" "),s("p",[t._v("「由一个或多个连续的文本行组成」这句话其实暗示了 Markdown 允许段落内的强迫换行（插入换行符），这个特性和其他大部分的 text-to-HTML 格式不一样（包括 Movable Type 的「Convert Line Breaks」选项），其它的格式会把每个换行符都转成<br />标签。")]),t._v(" "),s("p",[t._v("如果你确实想要依赖 Markdown 来插入<br />标签的话，在插入处先按入两个以上的空格然后回车。")]),t._v(" "),s("p",[t._v("的确，需要多费点事（多加空格）来产生<br />，但是简单地「每个换行都转换为<br />」的方法在 Markdown 中并不适合， Markdown 中 email 式的 区块引用 和多段落的 列表 在使用换行来排版的时候，不但更好用，还更方便阅读。")]),t._v(" "),s("h2",{attrs:{id:"标题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#标题"}},[t._v("#")]),t._v(" 标题")]),t._v(" "),s("p",[t._v("Markdown 支持两种标题的语法，类 Setext 和类 atx 形式。")]),t._v(" "),s("p",[t._v("类 Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），例如：")]),t._v(" "),s("pre",[s("code",[t._v("This is an H1\n=============\n\nThis is an H2\n-------------\n")])]),t._v(" "),s("h1",{attrs:{id:"this-is-an-h1"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#this-is-an-h1"}},[t._v("#")]),t._v(" This is an H1")]),t._v(" "),s("h2",{attrs:{id:"this-is-an-h2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#this-is-an-h2"}},[t._v("#")]),t._v(" This is an H2")])])}),[],!1,null,null,null);a.default=e.exports}}]);